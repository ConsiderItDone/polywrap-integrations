"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.populatePropertyType = exports.finalizePropertyDef = void 0;
var typeInfo_1 = require("../typeInfo");
exports.finalizePropertyDef = function (typeInfo) {
    return {
        enter: {
            // eslint-disable-next-line @typescript-eslint/naming-convention
            PropertyDefinition: function (def) {
                populatePropertyType(def, typeInfo);
                return def;
            },
        },
    };
};
function populatePropertyType(property, typeInfo) {
    var propertyType;
    if (property.array) {
        populateArrayType(property.array, typeInfo);
        propertyType = property.array;
    }
    else if (property.unresolvedObjectOrEnum) {
        propertyType = resolveObjectOrEnumKind(property, typeInfo);
    }
    else if (property.scalar) {
        propertyType = property.scalar;
    }
    else if (property.object) {
        propertyType = property.object;
    }
    else if (property.enum) {
        propertyType = property.enum;
    }
    else if (property.map) {
        propertyType = property.map;
    }
    else {
        throw Error("Property type is undefined, this should never happen.");
    }
    property.type = propertyType.type;
    property.required = propertyType.required;
}
exports.populatePropertyType = populatePropertyType;
function populateArrayType(array, typeInfo) {
    var baseTypeFound = false;
    var currentArray = array;
    while (!baseTypeFound) {
        if (currentArray.array) {
            currentArray = currentArray.array;
            populateArrayType(currentArray, typeInfo);
        }
        else if (currentArray.scalar ||
            currentArray.object ||
            currentArray.enum ||
            currentArray.unresolvedObjectOrEnum) {
            baseTypeFound = true;
        }
        else {
            throw Error("This should never happen, ArrayDefinition is malformed.\n" + JSON.stringify(array, null, 2));
        }
    }
    if (array.array) {
        array.item = array.array;
    }
    else if (array.unresolvedObjectOrEnum) {
        array.item = resolveObjectOrEnumKind(array, typeInfo);
    }
    else if (array.scalar) {
        array.item = array.scalar;
    }
    else if (array.enum) {
        array.item = array.enum;
    }
    else if (array.map) {
        array.item = array.map;
    }
    else {
        array.item = array.object;
    }
    if (!array.item) {
        throw Error("Array isn't valid.");
    }
    array.type = "[" + array.item.type + "]";
}
function resolveObjectOrEnumKind(property, typeInfo) {
    var _a, _b, _c, _d;
    if (!property.unresolvedObjectOrEnum) {
        throw Error("Type reference is undefined, this should never happen.");
    }
    var unresolved = property.unresolvedObjectOrEnum;
    // Check to see if the type is a part of the custom types defined inside the schema (objects, enums, envs)
    var customType = typeInfo.objectTypes.find(function (type) { return type.type === unresolved.type; });
    customType = customType
        ? customType
        : typeInfo.importedObjectTypes.find(function (type) { return type.type === unresolved.type; });
    var envType = typeInfo.envType;
    customType = customType
        ? customType
        : ((_a = envType.client) === null || _a === void 0 ? void 0 : _a.type) === unresolved.type
            ? envType.client
            : ((_b = envType.sanitized) === null || _b === void 0 ? void 0 : _b.type) === unresolved.type
                ? envType.sanitized
                : undefined;
    if (!customType) {
        customType = typeInfo.enumTypes.find(function (type) { return type.type === unresolved.type; });
        customType = customType
            ? customType
            : typeInfo.importedEnumTypes.find(function (type) { return type.type === unresolved.type; });
        if (!customType) {
            throw new Error("Unsupported type " + unresolved.type);
        }
        property.enum = typeInfo_1.createEnumRef({
            name: unresolved.name,
            required: (_c = unresolved.required) !== null && _c !== void 0 ? _c : undefined,
            type: unresolved.type,
        });
        property.unresolvedObjectOrEnum = null;
        return property.enum;
    }
    else {
        property.object = typeInfo_1.createObjectRef({
            name: property.unresolvedObjectOrEnum.name,
            required: (_d = property.unresolvedObjectOrEnum.required) !== null && _d !== void 0 ? _d : undefined,
            type: property.unresolvedObjectOrEnum.type,
        });
        property.unresolvedObjectOrEnum = null;
        return property.object;
    }
}
//# sourceMappingURL=finalizePropertyDef.js.map