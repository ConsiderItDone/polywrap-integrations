import { Uri, Client, MaybeAsync } from ".";
/**
 * Invocable plugin method.
 *
 * @param input Input arguments for the method, structured as
 * a map, removing the chance of incorrectly ordering arguments.
 * @param client The client instance requesting this invocation.
 * This client will be used for any sub-invokes that occur.
 */
export declare type PluginMethod<TInput extends Record<string, unknown> = Record<string, unknown>, TResult = unknown> = (input: TInput, client: Client) => MaybeAsync<TResult>;
export declare abstract class PluginModule<TConfig extends Record<string, unknown> = Record<string, unknown>, TEnv extends Record<string, unknown> = Record<string, unknown>, TClientEnv extends Record<string, unknown> = TEnv> {
    private _env;
    private _config;
    constructor(config: TConfig);
    get env(): TEnv;
    get config(): TConfig;
    _wrap_load_env(env: TEnv): void;
    _wrap_sanitize_env(clientEnv: TClientEnv, client: Client): Promise<TEnv>;
    _wrap_invoke<TInput extends Record<string, unknown> = Record<string, unknown>, TResult = unknown>(method: string, input: TInput, client: Client): Promise<TResult>;
    getMethod<TInput extends Record<string, unknown> = Record<string, unknown>, TResult = unknown>(method: string): PluginMethod<TInput, TResult> | undefined;
}
/** The plugin package's manifest */
export interface PluginPackageManifest {
    /** The Wrapper's schema */
    schema: string;
    /** All interface schemas implemented by this plugin. */
    implements: Uri[];
}
export declare type PluginPackage = {
    factory: () => PluginModule;
    manifest: PluginPackageManifest;
};
export declare type PluginFactory<TOpts> = (opts: TOpts) => PluginPackage;
